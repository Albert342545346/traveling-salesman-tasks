# Задачи коммивояжера
## Вступление
Представленная перед нами тема, как по мне является одной из самых важнейших в *комбинаторной оптимизации*. Задача коммивояжера используется в поиске самого выгодного маршрута. Так, например, перед походом в несколько магазинов вы определите кратчайший из всех. После чего пройдете по данному маршруту. Также происходит и здесь. Только вместо вас тут все просчитывает искусственный интеллект.
**Основная цель работы** – 1) В первой главе приводиться общая коммивояжера, описание и постановки этой задачи, математическая модель и описание существующих методов решения задачи коммивояжера;
2) Во второй главе – разработка двух выбранных методов – ветвей и
границ и ближайшего соседа, описание структуры программной реализации.
3) В третьей главе –проведение вычислительных экспериментов и
сравнительный анализ полученных результатов.
### Выполнение работы
Для того чтобы решить задачу, которую была перед нами поставлена, нужно поэтапно выполнять каждое действие. В самом начале нам нужно перейти в python packages и там скачать *matplotlib* и *numpy*. После чего мы можем приступать к выполнению работы.
### Первый этап
В них мы получим большое количество полезных данных и функций. О первом из них я сейчас расскажу.
***Numpy.Linspace()*** – функция которая задает интервал на графике. 
***Plot()*** – функция задающая расположение точек на графике, а также соединяющая их. Там же мы можем изменить вид и цвет линии.
***Show()*** – функция, которую вызывают после окончание работы, чтобы отобразить решение.
```
import matplotlib.pyplot as plt 
import numpy as np 
x = np.linspace(-5, 5) 
y = x**2
 plt.plot(x, y, ‘- -g')
 plt.show()
```

![xxxx](/img/Figure2.png)
### Второй этап
Теперь добавим еще несколько функций и попробуем использовать их в примере.
***random.rand()*** – функция получающая случайные данные которые автоматически заносятся в массив.
***scatter(x[0], y[0])*** – функция позволяющая отметить начало линии.
*В добавок к этому просчитаем длину первого отрезка при помощи теоремы Пифагора.*
```
import numpy as np
import matplotlib.pyplot as plt
x = np.random.rand(10)
y = np.random.rand(10)
plt.plot(x, y,'-g')
plt.scatter(x[0], y[0])
print(((x[1] - x[0]) ** 2 + (y[1] - y[0]) ** 2) ** 0.5)
plt.show()
```

![xxxxx](/img/Figure3.png)
### Третий этап
На этом этапе мы заменим случайные числа переменной **x** на свои собственные и найдем общую длину через цикл *for*. Но по причине того, что мы выводим свои числа, то у нас не будут соединяться две точки(первая и последняя).
Для этого стоит в самом начале выписать вот такую строчку **plt.plot([order[0], order[-1]], [y[0], y[-1]], "-g")**.
```
import numpy as np
import matplotlib.pyplot as plt

y = np.random.rand(10)
order = [0,1,2,3,4,5,6,7,8,9]
plt.plot([order[0], order[-1]], [y[0], y[-1]], "-g")
plt.plot(order, y, '-g')
plt.scatter(order[0], y[0])
def line(order, y):
    s = 0
    for i in range(len(order)):
        s += ((order[i] - order[i - 1]) ** 2 + (y[i] - y[i - 1]) ** 2) ** 0.5
    return s

d = line(order, y)
print((d + ((order[-1] - order[0]) ** 2 + (y[-1] - y[0]) ** 2) ** 0.5))
print(((order[1] - order[0]) ** 2 + (y[1] - y[0]) ** 2) ** 0.5)
plt.show()
```

![xxxxx](/img/Figure4.png)
### Четвертый этап
Следующим шагом мы будем использовать функцию *shuffle()*.
**shuffle()** - функция модуля *random* которая позволяет перемещать переменный в заданном массиве.
```
import numpy as np
import matplotlib.pyplot as plt

y = np.random.rand(10)
order = [0,1,2,3,4,5,6,7,8,9]
np.random.shuffle(y)
np.random.shuffle(order)
plt.plot([order[0], order[-1]], [y[0], y[-1]], "-g")
plt.plot(order, y, '-g')
plt.scatter(order[0], y[0])
def line(order, y):
    s = 0
    for i in range(len(order)):
        s += ((order[i] - order[i - 1]) ** 2 + (y[i] - y[i - 1]) ** 2) ** 0.5
    return s
d = line(order, y)
print((d + ((order[-1] - order[0]) ** 2 + (y[-1] - y[0]) ** 2) ** 0.5))
print(((order[1] - order[0]) ** 2 + (y[1] - y[0]) ** 2) ** 0.5)
plt.show()
```


![xxx](/img/Figure1.png)
### Пятый этап
*Когда разобрали все нужные нам для работы команды, функции и библиотеки, мы можем приступить к написанию кода, который будет просчитывать все возможные пути и будет выводить наилучший.*
```
import numpy as np
import matplotlib.pyplot as plt
from itertools import permutations
from random import *

x = [randrange(0, 10) for _ in range(5)]
y = [randrange(0, 10) for _ in range(5)]

d = []
for i in range(len(x)):
    d.append((x[i], y[i]))
d = [list(i) for i in permutations(d, len(d))]
key = {}
for el in d:
    track = 0
    for i in range(len(el)-1):
        track += np.sqrt((el[i+1][0] - el[i][0])**2+(el[i+1][1] + el[i][1])**2)
    key[track] = d.index(el)
k = key[min(key.keys())]
print(d[k], k)
print(key)
plt.scatter([i[0] for i in d[k]], [i[1] for i in d[k]])
plt.plot([i[0] for i in d[k]], [i[1] for i in d[k]])
plt.plot([d[k][0][0], d[k][-1][0]], [d[k][0][1], d[k][-1][1]])
plt.show()
```
![xxxxxx](/img/Figure5.png)
### Шестой этап
*В последнем этапе нам остается добавить лишь время для проверки прохождения заданного маршрута.


![xxxxxxxxxx](/img/Рисунок1.png)


![xxxxxxxxxx](/img/Рисунок3.png)


![xxxxxxxxxxxx](/img/Figure6.png)