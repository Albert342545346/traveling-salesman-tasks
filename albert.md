# Задачи коммивояжера
## Вступление
Представленная перед нами тема, как по мне является одной из самых важнейших в *комбинаторной оптимизации*. Задача коммивояжера используется в поиске самого выгодного маршрута. Так, например, перед походом в несколько магазинов вы определите кратчайший из всех. После чего пройдете по данному маршруту. Также происходит и здесь. Только вместо вас тут все просчитывает искусственный интеллект.
**Основная цель работы** – 1) В первой главе приводиться общая коммивояжера, описание и постановки этой задачи, математическая модель и описание существующих методов решения задачи коммивояжера;
2) Во второй главе – разработка двух выбранных методов – ветвей и
границ и ближайшего соседа, описание структуры программной реализации.
3) В третьей главе –проведение вычислительных экспериментов и
сравнительный анализ полученных результатов.
### Выполнение работы
Для того чтобы решить задачу, которую была перед нами поставлена, нужно поэтапно выполнять каждое действие. В самом начале нам нужно перейти в python packages и там скачать *matplotlib* и *numpy*. После чего мы можем приступать к выполнению работы.
### Первый этап
В них мы получим большое количество полезных данных и функций. О первом из них я сейчас расскажу.
***Numpy.Linspace()*** – функция которая задает интервал на графике. 
***Plot()*** – функция задающая расположение точек на графике, а также соединяющая их. Там же мы можем изменить вид и цвет линии.
***Show()*** – функция, которую вызывают после окончание работы, чтобы отобразить решение.
```
import matplotlib.pyplot as plt 
import numpy as np 
x = np.linspace(-5, 5) 
y = x**2
 plt.plot(x, y, ‘- -g')
 plt.show()
```

![xxxx](/img/Figure2.png)
### Второй этап
Теперь добавим еще несколько функций и попробуем использовать их в примере.
***random.rand()*** – функция получающая случайные данные которые автоматически заносятся в массив.
***scatter(x[0], y[0])*** – функция позволяющая отметить начало линии.
*В добавок к этому просчитаем длину первого отрезка при помощи теоремы Пифагора.*
```
import numpy as np
import matplotlib.pyplot as plt
x = np.random.rand(10)
y = np.random.rand(10)
plt.plot(x, y,'-g')
plt.scatter(x[0], y[0])
print(((x[1] - x[0]) ** 2 + (y[1] - y[0]) ** 2) ** 0.5)
plt.show()
```

![xxxxx](/img/Figure3.png)
### Третий этап
На этом этапе мы заменим случайные числа переменной **x** на свои собственные и найдем общую длину через цикл *for*. Но по причине того, что мы выводим свои числа, то у нас не будут соединяться две точки(первая и последняя).
Для этого стоит в самом начале выписать вот такую строчку **plt.plot([order[0], order[-1]], [y[0], y[-1]], "-g")**.
```
import numpy as np
import matplotlib.pyplot as plt

y = np.random.rand(10)
order = [0,1,2,3,4,5,6,7,8,9]
plt.plot([order[0], order[-1]], [y[0], y[-1]], "-g")
plt.plot(order, y, '-g')
plt.scatter(order[0], y[0])
def line(order, y):
    s = 0
    for i in range(len(order)):
        s += ((order[i] - order[i - 1]) ** 2 + (y[i] - y[i - 1]) ** 2) ** 0.5
    return s

d = line(order, y)
print((d + ((order[-1] - order[0]) ** 2 + (y[-1] - y[0]) ** 2) ** 0.5))
print(((order[1] - order[0]) ** 2 + (y[1] - y[0]) ** 2) ** 0.5)
plt.show()
```

![xxxxx](/img/Figure4.png)
### Четвертый этап
Следующим шагом мы будем использовать функцию *shuffle()*.
**shuffle()** - функция модуля *random* которая позволяет перемещать переменный в заданном массиве.
```
import numpy as np
import matplotlib.pyplot as plt

y = np.random.rand(10)
order = [0,1,2,3,4,5,6,7,8,9]
np.random.shuffle(y)
np.random.shuffle(order)
plt.plot([order[0], order[-1]], [y[0], y[-1]], "-g")
plt.plot(order, y, '-g')
plt.scatter(order[0], y[0])
def line(order, y):
    s = 0
    for i in range(len(order)):
        s += ((order[i] - order[i - 1]) ** 2 + (y[i] - y[i - 1]) ** 2) ** 0.5
    return s
d = line(order, y)
print((d + ((order[-1] - order[0]) ** 2 + (y[-1] - y[0]) ** 2) ** 0.5))
print(((order[1] - order[0]) ** 2 + (y[1] - y[0]) ** 2) ** 0.5)
plt.show()
```


![xxx](/img/Figure1.png)
